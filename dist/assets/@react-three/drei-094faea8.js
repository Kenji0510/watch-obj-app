import{r as Oe,a as r}from"../vendor-1e052ad9.js";import{V as Z,D as je,O as he,P as pe,a as Y,W as Le,L as ue,H as We,b as Te,F as Fe,B as Ae,S as ze,c as $e,C as De}from"../three-c0757b61.js";import{u as S,a as re}from"./fiber-f89b865d.js";import{O as He}from"../three-stdlib-8df15805.js";var fe={},ge,de=Oe;ge=fe.createRoot=de.createRoot,fe.hydrateRoot=de.hydrateRoot;function Be(t){let e;const n=new Set,s=(f,l)=>{const o=typeof f=="function"?f(e):f;if(o!==e){const d=e;e=l?o:Object.assign({},e,o),n.forEach(b=>b(e,d))}},i=()=>e,c=(f,l=i,o=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let d=l(e);function b(){const P=l(e);if(!o(d,P)){const w=d;f(d=P,w)}}return n.add(b),()=>n.delete(b)},p={setState:s,getState:i,subscribe:(f,l,o)=>l||o?c(f,l,o):(n.add(f),()=>n.delete(f)),destroy:()=>n.clear()};return e=t(s,i,p),p}const Ie=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),me=Ie?r.useEffect:r.useLayoutEffect;function Ve(t){const e=typeof t=="function"?Be(t):t,n=(s=e.getState,i=Object.is)=>{const[,c]=r.useReducer(m=>m+1,0),a=e.getState(),h=r.useRef(a),p=r.useRef(s),f=r.useRef(i),l=r.useRef(!1),o=r.useRef();o.current===void 0&&(o.current=s(a));let d,b=!1;(h.current!==a||p.current!==s||f.current!==i||l.current)&&(d=s(a),b=!i(o.current,d)),me(()=>{b&&(o.current=d),h.current=a,p.current=s,f.current=i,l.current=!1});const P=r.useRef(a);me(()=>{const m=()=>{try{const O=e.getState(),L=p.current(O);f.current(o.current,L)||(h.current=O,o.current=L,c())}catch{l.current=!0,c()}},M=e.subscribe(m);return e.getState()!==P.current&&m(),M},[]);const w=b?d:o.current;return r.useDebugValue(w),w};return Object.assign(n,e),n[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const s=[n,e];return{next(){const i=s.length<=0;return{value:s.shift(),done:i}}}},n}function I(){return I=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t},I.apply(this,arguments)}const k=new Z,se=new Z,Ne=new Z;function _e(t,e,n){const s=k.setFromMatrixPosition(t.matrixWorld);s.project(e);const i=n.width/2,c=n.height/2;return[s.x*i+i,-(s.y*c)+c]}function Ge(t,e){const n=k.setFromMatrixPosition(t.matrixWorld),s=se.setFromMatrixPosition(e.matrixWorld),i=n.sub(s),c=e.getWorldDirection(Ne);return i.angleTo(c)>Math.PI/2}function Ze(t,e,n,s){const i=k.setFromMatrixPosition(t.matrixWorld),c=i.clone();c.project(e),n.setFromCamera(c,e);const a=n.intersectObjects(s,!0);if(a.length){const h=a[0].distance;return i.distanceTo(n.ray.origin)<h}return!0}function ke(t,e){if(e instanceof he)return e.zoom;if(e instanceof pe){const n=k.setFromMatrixPosition(t.matrixWorld),s=se.setFromMatrixPosition(e.matrixWorld),i=e.fov*Math.PI/180,c=n.distanceTo(s);return 1/(2*Math.tan(i/2)*c)}else return 1}function Ue(t,e,n){if(e instanceof pe||e instanceof he){const s=k.setFromMatrixPosition(t.matrixWorld),i=se.setFromMatrixPosition(e.matrixWorld),c=s.distanceTo(i),a=(n[1]-n[0])/(e.far-e.near),h=n[1]-a*e.far;return Math.round(a*c+h)}}const ne=t=>Math.abs(t)<1e-10?0:t;function ve(t,e,n=""){let s="matrix3d(";for(let i=0;i!==16;i++)s+=ne(e[i]*t.elements[i])+(i!==15?",":")");return n+s}const Je=(t=>e=>ve(e,t))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Ke=(t=>(e,n)=>ve(e,t(n),"translate(-50%,-50%)"))(t=>[1/t,1/t,1/t,1,-1/t,-1/t,-1/t,-1,1/t,1/t,1/t,1,1,1,1,1]);function Qe(t){return t&&typeof t=="object"&&"current"in t}const st=r.forwardRef(({children:t,eps:e=.001,style:n,className:s,prepend:i,center:c,fullscreen:a,portal:h,distanceFactor:p,sprite:f=!1,transform:l=!1,occlude:o,onOcclude:d,castShadow:b,receiveShadow:P,material:w,geometry:m,zIndexRange:M=[16777271,0],calculatePosition:O=_e,as:L="div",wrapperClass:y,pointerEvents:g="auto",...u},W)=>{const{gl:T,camera:x,scene:V,size:E,raycaster:U,events:xe,viewport:be}=S(),[R]=r.useState(()=>document.createElement(L)),q=r.useRef(),j=r.useRef(null),oe=r.useRef(0),J=r.useRef([0,0]),N=r.useRef(null),ee=r.useRef(null),H=(h==null?void 0:h.current)||xe.connected||T.domElement.parentNode,A=r.useRef(null),K=r.useRef(!1),Q=r.useMemo(()=>o&&o!=="blending"||Array.isArray(o)&&o.length&&Qe(o[0]),[o]);r.useLayoutEffect(()=>{const C=T.domElement;o&&o==="blending"?(C.style.zIndex=`${Math.floor(M[0]/2)}`,C.style.position="absolute",C.style.pointerEvents="none"):(C.style.zIndex=null,C.style.position=null,C.style.pointerEvents=null)},[o]),r.useLayoutEffect(()=>{if(j.current){const C=q.current=ge(R);if(V.updateMatrixWorld(),l)R.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const v=O(j.current,x,E);R.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${v[0]}px,${v[1]}px,0);transform-origin:0 0;`}return H&&(i?H.prepend(R):H.appendChild(R)),()=>{H&&H.removeChild(R),C.unmount()}}},[H,l]),r.useLayoutEffect(()=>{y&&(R.className=y)},[y]);const ie=r.useMemo(()=>l?{position:"absolute",top:0,left:0,width:E.width,height:E.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:c?"translate3d(-50%,-50%,0)":"none",...a&&{top:-E.height/2,left:-E.width/2,width:E.width,height:E.height},...n},[n,c,a,E,l]),ye=r.useMemo(()=>({position:"absolute",pointerEvents:g}),[g]);r.useLayoutEffect(()=>{if(K.current=!1,l){var C;(C=q.current)==null||C.render(r.createElement("div",{ref:N,style:ie},r.createElement("div",{ref:ee,style:ye},r.createElement("div",{ref:W,className:s,style:n,children:t}))))}else{var v;(v=q.current)==null||v.render(r.createElement("div",{ref:W,style:ie,className:s,children:t}))}});const B=r.useRef(!0);re(C=>{if(j.current){x.updateMatrixWorld(),j.current.updateWorldMatrix(!0,!1);const v=l?J.current:O(j.current,x,E);if(l||Math.abs(oe.current-x.zoom)>e||Math.abs(J.current[0]-v[0])>e||Math.abs(J.current[1]-v[1])>e){const z=Ge(j.current,x);let F=!1;Q&&(o!=="blending"?F=[V]:Array.isArray(o)&&(F=o.map($=>$.current)));const _=B.current;if(F){const $=Ze(j.current,x,U,F);B.current=$&&!z}else B.current=!z;_!==B.current&&(d?d(!B.current):R.style.display=B.current?"block":"none");const X=Math.floor(M[0]/2),Se=o?Q?[M[0],X]:[X-1,0]:M;if(R.style.zIndex=`${Ue(j.current,x,Se)}`,l){const[$,ae]=[E.width/2,E.height/2],te=x.projectionMatrix.elements[5]*ae,{isOrthographicCamera:le,top:Ee,left:we,bottom:Re,right:Pe}=x,Me=Je(x.matrixWorldInverse),Ce=le?`scale(${te})translate(${ne(-(Pe+we)/2)}px,${ne((Ee+Re)/2)}px)`:`translateZ(${te}px)`;let D=j.current.matrixWorld;f&&(D=x.matrixWorldInverse.clone().transpose().copyPosition(D).scale(j.current.scale),D.elements[3]=D.elements[7]=D.elements[11]=0,D.elements[15]=1),R.style.width=E.width+"px",R.style.height=E.height+"px",R.style.perspective=le?"":`${te}px`,N.current&&ee.current&&(N.current.style.transform=`${Ce}${Me}translate(${$}px,${ae}px)`,ee.current.style.transform=Ke(D,1/((p||10)/400)))}else{const $=p===void 0?1:ke(j.current,x)*p;R.style.transform=`translate3d(${v[0]}px,${v[1]}px,0) scale(${$})`}J.current=v,oe.current=x.zoom}}if(!Q&&A.current&&!K.current)if(l){if(N.current){const v=N.current.children[0];if(v!=null&&v.clientWidth&&v!=null&&v.clientHeight){const{isOrthographicCamera:z}=x;if(z||m)u.scale&&(Array.isArray(u.scale)?u.scale instanceof Z?A.current.scale.copy(u.scale.clone().divideScalar(1)):A.current.scale.set(1/u.scale[0],1/u.scale[1],1/u.scale[2]):A.current.scale.setScalar(1/u.scale));else{const F=(p||10)/400,_=v.clientWidth*F,X=v.clientHeight*F;A.current.scale.set(_,X,1)}K.current=!0}}}else{const v=R.children[0];if(v!=null&&v.clientWidth&&v!=null&&v.clientHeight){const z=1/be.factor,F=v.clientWidth*z,_=v.clientHeight*z;A.current.scale.set(F,_,1),K.current=!0}A.current.lookAt(C.camera.position)}});const ce=r.useMemo(()=>({vertexShader:l?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[l]);return r.createElement("group",I({},u,{ref:j}),o&&!Q&&r.createElement("mesh",{castShadow:b,receiveShadow:P,ref:A},m||r.createElement("planeGeometry",null),w||r.createElement("shaderMaterial",{side:je,vertexShader:ce.vertexShader,fragmentShader:ce.fragmentShader})))});let G=0;const ot=Ve(t=>(Y.onStart=(e,n,s)=>{t({active:!0,item:e,loaded:n,total:s,progress:(n-G)/(s-G)*100})},Y.onLoad=()=>{t({active:!1})},Y.onError=e=>t(n=>({errors:[...n.errors,e]})),Y.onProgress=(e,n,s)=>{n===s&&(G=s),t({active:!0,item:e,loaded:n,total:s,progress:(n-G)/(s-G)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0}));function Xe(t){return function(e){t.forEach(function(n){typeof n=="function"?n(e):n!=null&&(n.current=e)})}}function Ye(t,e,n){const s=S(d=>d.size),i=S(d=>d.viewport),c=typeof t=="number"?t:s.width*i.dpr,a=typeof e=="number"?e:s.height*i.dpr,h=(typeof t=="number"?n:t)||{},{samples:p=0,depth:f,...l}=h,o=r.useMemo(()=>{const d=new Le(c,a,{minFilter:ue,magFilter:ue,type:We,...l});return f&&(d.depthTexture=new Te(c,a,Fe)),d.samples=p,d},[]);return r.useLayoutEffect(()=>{o.setSize(c,a),p&&(o.samples=p)},[p,o,c,a]),r.useEffect(()=>()=>o.dispose(),[]),o}const qe=t=>typeof t=="function",it=r.forwardRef(({envMap:t,resolution:e=256,frames:n=1/0,makeDefault:s,children:i,...c},a)=>{const h=S(({set:m})=>m),p=S(({camera:m})=>m),f=S(({size:m})=>m),l=r.useRef(null),o=r.useRef(null),d=Ye(e);r.useLayoutEffect(()=>{c.manual||(l.current.aspect=f.width/f.height)},[f,c]),r.useLayoutEffect(()=>{l.current.updateProjectionMatrix()});let b=0,P=null;const w=qe(i);return re(m=>{w&&(n===1/0||b<n)&&(o.current.visible=!1,m.gl.setRenderTarget(d),P=m.scene.background,t&&(m.scene.background=t),m.gl.render(m.scene,l.current),m.scene.background=P,m.gl.setRenderTarget(null),o.current.visible=!0,b++)}),r.useLayoutEffect(()=>{if(s){const m=p;return h(()=>({camera:l.current})),()=>h(()=>({camera:m}))}},[l,s,h]),r.createElement(r.Fragment,null,r.createElement("perspectiveCamera",I({ref:Xe([l,a])},c),!w&&i),r.createElement("group",{ref:o},w&&i(d.texture)))}),ct=r.forwardRef(({makeDefault:t,camera:e,regress:n,domElement:s,enableDamping:i=!0,keyEvents:c=!1,onChange:a,onStart:h,onEnd:p,...f},l)=>{const o=S(u=>u.invalidate),d=S(u=>u.camera),b=S(u=>u.gl),P=S(u=>u.events),w=S(u=>u.setEvents),m=S(u=>u.set),M=S(u=>u.get),O=S(u=>u.performance),L=e||d,y=s||P.connected||b.domElement,g=r.useMemo(()=>new He(L),[L]);return re(()=>{g.enabled&&g.update()},-1),r.useEffect(()=>(c&&g.connect(c===!0?y:c),g.connect(y),()=>void g.dispose()),[c,y,n,g,o]),r.useEffect(()=>{const u=x=>{o(),n&&O.regress(),a&&a(x)},W=x=>{h&&h(x)},T=x=>{p&&p(x)};return g.addEventListener("change",u),g.addEventListener("start",W),g.addEventListener("end",T),()=>{g.removeEventListener("start",W),g.removeEventListener("end",T),g.removeEventListener("change",u)}},[a,h,p,g,o,w]),r.useEffect(()=>{if(t){const u=M().controls;return m({controls:g}),()=>m({controls:u})}},[t,g]),r.createElement("primitive",I({ref:l,object:g,enableDamping:i},f))}),at=r.forwardRef(function({children:e,disable:n,disableX:s,disableY:i,disableZ:c,left:a,right:h,top:p,bottom:f,front:l,back:o,onCentered:d,precise:b=!0,cacheKey:P=0,...w},m){const M=r.useRef(null),O=r.useRef(null),L=r.useRef(null);return r.useLayoutEffect(()=>{O.current.matrixWorld.identity();const y=new Ae().setFromObject(L.current,b),g=new Z,u=new ze,W=y.max.x-y.min.x,T=y.max.y-y.min.y,x=y.max.z-y.min.z;y.getCenter(g),y.getBoundingSphere(u);const V=p?T/2:f?-T/2:0,E=a?-W/2:h?W/2:0,U=l?x/2:o?-x/2:0;O.current.position.set(n||s?0:-g.x+E,n||i?0:-g.y+V,n||c?0:-g.z+U),typeof d<"u"&&d({parent:M.current.parent,container:M.current,width:W,height:T,depth:x,boundingBox:y,boundingSphere:u,center:g,verticalAlignment:V,horizontalAlignment:E,depthAlignment:U})},[P,d,p,a,l,n,s,i,c,b,h,f,o]),r.useImperativeHandle(m,()=>M.current,[]),r.createElement("group",I({ref:M},w),r.createElement("group",{ref:O},r.createElement("group",{ref:L},e)))});function lt({all:t,scene:e,camera:n}){const s=S(({gl:a})=>a),i=S(({camera:a})=>a),c=S(({scene:a})=>a);return r.useLayoutEffect(()=>{const a=[];t&&(e||c).traverse(f=>{f.visible===!1&&(a.push(f),f.visible=!0)}),s.compile(e||c,n||i);const h=new $e(128);new De(.01,1e5,h).update(s,e||c),h.dispose(),a.forEach(f=>f.visible=!1)},[]),null}export{at as C,st as H,ct as O,lt as P,I as _,it as a,fe as b,Ve as c,ot as u};
